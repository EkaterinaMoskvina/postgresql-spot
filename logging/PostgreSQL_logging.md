## Логирование
Журнал сервера базы данных желательно сохранять где-либо, а не просто сбрасывать его в /dev/null. Этот журнал бесценен при диагностике проблем. Однако он может быть очень объёмным (особенно при высоких уровнях отладки), так что хранить его неограниченно долго вы вряд ли захотите. Поэтому необходимо организовать ротацию журнальных файлов так, чтобы новые файлы создавались, а старые удалялись через разумный промежуток времени.

### Куда записываем логи
`log_destination (string)`:
PostgreSQL поддерживает несколько методов протоколирования сообщений сервера: stderr, csvlog и syslog. На Windows также поддерживается eventlog. По умолчанию используется stderr. csvlog может быть полезен для машинной обработки логов и загрузки их в базу данных. syslog может не записывать некоторые сообщения, поэтому дальше не рассматривается. Можно задавать сразу несколько методов через запятую.

Если присутствует указание stderr или csvlog, создаётся файл current_logfiles, в который записывается расположение файла(ов) журнала, в настоящее время используемого сборщиком сообщений для соответствующего назначения.

`logging_collector (boolean)`: Параметр включает сборщик сообщений (logging collector). Это фоновый процесс, который собирает отправленные в stderr сообщения и перенаправляет их в журнальные файлы.

| Параметр | Описание     |
| :------------- | :------------- |
| log_directory (string)       | При включённом logging_collector, определяет каталог, в котором создаются журнальные файлы. Можно задавать как абсолютный путь, так и относительный от каталога данных кластера. |
| log_filename (string)       | При включённом logging_collector задаёт имена журнальных файлов. Можно использовать спецификаторы % для включения в имена файлов информации о дате и времени (например postgresql-%Y-%m-%d_%H%M%S.log).  |

### Ротация логов
`log_truncate_on_rotation (boolean)`: Если параметр logging_collector включён, PostgreSQL будет перезаписывать существующие журнальные файлы, а не дописывать в них. Однако, перезапись при переключении на новый файл возможна только в результате ротации по времени, но не при старте сервера или ротации по размеру файла. При выключенном параметре всегда продолжается запись в существующий файл. Например, включение этого параметра в комбинации с log_filename равным postgresql-%H.log, приведёт к генерации 24-х часовых журнальных файлов, которые циклически перезаписываются. Параметр можно задать только в конфигурационных файлах или в командной строке при запуске сервера.

**Пример**: для хранения журнальных файлов в течение 7 дней, по одному файлу на каждый день с именами вида server_log.Mon, server_log.Tue и т. д., а также с автоматической перезаписью файлов прошлой недели, нужно установить log_filename в server_log.%a, log_truncate_on_rotation в on и log_rotation_age в 1440.

| Параметр | Описание     |
| :------------- | :------------- |
| log_rotation_age (integer)       | При включённом logging_collector определяет максимальное время жизни отдельного журнального файла в минутах. После того как прошло заданное количество минут, создаётся новый журнальный файл. |
| log_rotation_size (integer)       | Тоже самое, только в килобайтах. |

### Когда записываем в логи
| Параметр | Описание     |
| :------------- | :------------- |
| log_min_messages (enum) | DEBUG5, DEBUG4, DEBUG3, DEBUG2, DEBUG1, INFO, NOTICE, WARNING, ERROR, LOG, FATAL и PANIC. Каждый из перечисленных уровней включает все идущие после него. |
| log_min_error_statement (enum) | DEBUG5, DEBUG4, DEBUG3, DEBUG2, DEBUG1, INFO, NOTICE, WARNING, ERROR, LOG, FATAL и PANIC.  Управляет тем, какие SQL-операторы, завершившиеся ошибкой, записываются в журнал сервера. SQL-оператор будет записан в журнал, если он завершится ошибкой с указанным уровнем важности или выше. |
| log_min_duration_statement (integer) | Записывает в журнал продолжительность выполнения всех команд, время работы которых равно или превышает указанное количество миллисекунд. Значение 0 (ноль) заставляет записывать продолжительность работы всех команд. Значение -1 (по умолчанию) запрещает регистрировать продолжительность выполнения операторов. |

#### Уровни важности сообщений
| Уровень | Описание     |
| :------------- | :------------- |
| DEBUG1..DEBUG5 | Более детальная информация для разработчиков. Чем больше номер, тем детальнее. |
| INFO | Неявно запрошенная пользователем информация, например вывод команды VACUUM VERBOSE. |
| NOTICE | Информация, которая может быть полезной пользователям. Например, уведомления об усечении длинных идентификаторов. |
| WARNING | Предупреждения о возможных проблемах. Например, COMMIT вне транзакционного блока. |
| ERROR | Сообщает об ошибке, из-за которой прервана текущая команда. |
| LOG | Информация, полезная для администраторов. Например, выполнение контрольных точек. |
| FATAL | Сообщает об ошибке, из-за которой прервана текущая сессия. |
| PANIC | Сообщает об ошибке, из-за которой прерваны все сессии.|

### Что записываем в логи
`log_duration (boolean)`: Записывает продолжительность каждой завершённой команды. Включение этого параметра и установка log_min_duration_statement в 0 (ноль) различаются. Разница в том, что при превышении значения log_min_duration_statement, в журнал записывается текст запроса, а при включении log_duration нет. Таким образом, при log_duration = on и log_min_duration_statement больше нуля, в журнал сервера будет записываться продолжительность выполнения всех команд, а текст запросов только для команд, превысивших заданное значение. Такое поведение может оказаться полезным при сборе статистики в условиях большой нагрузки.

`log_line_prefix (string)`: Строка, в стиле функции printf, которая выводится в начале каждой строки журнала сообщений. С символов % начинаются управляющие последовательности, которые заменяются статусной информацией, описанной ниже. Неизвестные управляющие последовательности игнорируются. Все остальные символы напрямую копируются в выводимую строку. Статусная информация может быть выровнена по ширине влево или вправо указанием числа после % и перед кодом последовательности. Отрицательное число дополняет значение пробелами справа до заданной ширины, а положительное число — слева.

| Спецсимвол | Описание     |
| :------------- | :------------- |
| %a	| Имя приложения (application_name) |
| %u		| Имя пользователя |
| %d		| Имя базы данных |
| %r		| Имя удалённого узла или IP-адрес, а также номер порта |
| %h		| Имя удалённого узла или IP-адрес |
| %p		| Идентификатор процесса |
| %t		| Штамп времени, без миллисекунд |
| %m		| Штамп времени, с миллисекундами |
| %n		| Штамп времени, с миллисекундами (в виде времени Unix) |
| %i		| Тег команды: тип текущей команды в сессии |
| %e		| Код ошибки SQLSTATE	 |
| %l		| Номер строки журнала для каждой сессии или процесса. Начинается с 1 |
| %s		| Штамп времени начала процесса |
| %v		| Идентификатор виртуальной транзакции (backendID/localXID) |
| %x		| Идентификатор транзакции (0 если не присвоен) |
| %| %	Выводит %  |

| Параметр | Описание     |
| :------------- | :------------- |
| log_checkpoints (boolean) | Включает протоколирование выполнения контрольных точек и точек перезапуска сервера. При этом записывается некоторая статистическая информация. Например, число записанных буферов и время, затраченное на их запись. |
| log_connections (boolean) | Включает протоколирование всех попыток подключения к серверу, в том числе успешного завершения аутентификации клиентов. Некоторые программы, например psql, предпринимают две попытки подключения (первая для определения, нужен ли пароль). Поэтому дублирование сообщения «connection received» не обязательно говорит о наличии проблемы.|
| log_disconnections (boolean) | Включает протоколирование завершения сеанса. В журнал выводится примерно та же информация, что и с log_connections, плюс длительность сеанса.|
| log_error_verbosity (enum) | Управляет количеством детальной информации, записываемой в журнал сервера для каждого сообщения. Допустимые значения: TERSE, DEFAULT и VERBOSE. Каждое последующее значение добавляет больше полей в выводимое сообщение. Для TERSE из сообщения об ошибке исключаются поля DETAIL, HINT, QUERY и CONTEXT. Для VERBOSE в сообщение включается код ошибки SQLSTATE, а также имя файла с исходным кодом, имя функции и номер строки сгенерировавшей ошибку.  |
| log_lock_waits (boolean) | Определяет, нужно ли фиксировать в журнале события, когда сеанс ожидает получения блокировки дольше, чем указано в deadlock_timeout. Это позволяет выяснить, не связана ли низкая производительность с ожиданием блокировок.  |
| log_statement (enum) | Управляет тем, какие SQL-команды записывать в журнал. Допустимые значения: none (отключено), ddl, mod и all (все команды). ddl записывает все команды определения данных, такие как CREATE, ALTER, DROP. mod записывает все команды ddl, а также команды изменяющие данные, такие как INSERT, UPDATE, DELETE, TRUNCATE и COPY FROM. PREPARE, EXECUTE и EXPLAIN ANALYZE также записываются, если вызваны для команды соответствующего типа. Если клиент использует расширенный протокол запросов, то запись происходит на фазе выполнения и содержит значения всех связанных переменных (если есть символы одиночных кавычек, то они удваиваются).  |
| log_temp_files (integer) | Управляет включением в журнал информации об именах и размерах временных файлов. Временные файлы могут использоваться для сортировок, хеширования и временного хранения результатов запросов. На каждый временный файл, при его удалении, в журнал записывается отдельное сообщение. Значение 0 говорит о том, что нужно записывать информацию о всех временных файлах. Положительное значение задаёт размер временных файлов в килобайтах, при достижении или превышении которого, информация о временном файле будет записана. Значение по умолчанию -1, что отключает запись информации о временных файлах.  |
| llog_timezone (string) | Устанавливает часовой пояс для штампов времени при записи в журнал сервера. В отличие от TimeZone, это значение одинаково для всех баз данных кластера, поэтому для всех сессий используются согласованные значения штампов времени.  |

### Дополнительные инструменты
[pgBadger](http://dalibo.github.io/pgbadger/) – инструмент для сложного анализа файлов журнала. Можно строить различные html отчеты с разрезами топ медленных, топ частых запросов и т.д. Можно преобразовывать лог в json файл для машинной обработки.

[check_postgres](https://bucardo.org/check_postgres/) – может посылать уведомления в Nagios, когда в журнале появляются важные сообщения, а также при обнаружении других нестандартных ситуаций.

[tail_n_mail](https://bucardo.org/tail_n_mail/) –  может делать рассылки на почту при обнаружении в логах чего-то подозрительного или требующего внимания.
[Logstash](https://www.elastic.co/products/logstash) – можно использовать вместе с ELK стеком для парсинга (Logstash), хранения (Elastic), красивого отображения и анализа(Kibana) логов (продвинутый pgBadger).



### Источники
- [Документация](https://postgrespro.ru/docs/postgrespro/10/runtime-config-logging) postgrespro.ru
