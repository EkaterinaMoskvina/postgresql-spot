## Архитектура PostgreSQL
### Внутренние процессы
![db_processes](db_processes.png)
Сервер PostgreSQL состоит из следующих проессов
- основной серверный процесс, являющийся родителем всех остальных процессов и управляющий ими;
- backend процессы, отвечающие за выполнение запросов от клиентов;
- внутренние процессы (background processes), обслуживающие БД (VACUUM, CHECKPOINT и другие);
- процессы репликации (осуществляющие потоковую репликацию);
- background worker процессы, созданные пользователями.

Внутренние процессы

| Процесс | Описание     |
| :------------- | :------------- |
| background writer      | In this process, dirty pages on the shared buffer pool are written to a persistent storage (e.g., HDD, SSD) on a regular basis gradually. (In version 9.1 or earlier, it was also responsible for checkpoint process.)       |
| checkpointer      | In this process in version 9.2 or later, checkpoint process is performed.       |
| autovacuum launcher      | The autovacuum-worker processes are invoked for vacuum process periodically. (More precisely, it requests to create the autovacuum workers to the postgres server.)       |
| WAL writer      | This process writes and flushes periodically the WAL data on the WAL buffer to persistent storage.       |
| statistics collector      | In this process, statistics information such as for pg_stat_activity and for pg_stat_database, etc. is collected.       |
| logging collector (logger)	      | This process writes error messages into log files.       |
| archiver      | In this process, archiving logging is executed.       |

---
**NOTE**

Больше информации про `VACUUM` в PostgreSQL можно найти в разделе [vacuum](https://github.com/yum-install-brains/postgresql-spot/blob/master/vacuum/postgresql_vacuum.md).

---

### Memory architecture
![db_memory](db_memory.png)
Память в PostgreSQL делится на две большие категории
- локальная память (своя у каждого процесса);
- общая память (общая для использования всеми процессами).

Каждый backend процесс выделяет себе локальную память для выполнения запросов. Локальная память в свою очередь разделяется на несколько областей
- work_mem (Executor uses this area for sorting tuples by ORDER BY and DISTINCT operations, and for joining tables by merge-join and hash-join operations);
- maintenance_work_mem (Some kinds of maintenance operations (e.g., VACUUM, REINDEX) use this area);
- temp_buffers (Executor uses this area for storing temporary tables).

Общая память выделяется серверу PostgreSQL при его запуске и также разделяется на несколько областей
- shared buffer pool (PostgreSQL loads pages within tables and indexes from a persistent storage to here, and operates them directly);
- WAL buffer (To ensure that no data has been lost by server failures, PostgreSQL supports the WAL mechanism. WAL data (also referred to as XLOG records) are transaction log in PostgreSQL; and WAL buffer is a buffering area of the WAL data before writing to a persistent storage);
- commit log (Commit Log(CLOG) keeps the states of all transactions (e.g., in_progress,committed,aborted) for Concurrency Control (CC) mechanism).

Также к общей памяти относятся области
- Sub-areas for the various access control mechanisms. (e.g., semaphores, lightweight locks, shared and exclusive locks, etc)
- Sub-areas for the various background processes, such as checkpointer and autovacuum.
- Sub-areas for transaction processing such as save-point and two-phase-commit.
- and others.

### Буферный кэш (shared buffers)
Буферный кэш используется для сглаживания скорости работы памяти и дисков. Он состоит из массива буферов, которые содержат страницы (блоки) данных и дополнительную информацию об этих страницах. Размер страницы обычно составляет 8 КБ, хотя может устанавливаться при сборке. Буферный кэш, как и другие структуры в памяти, защищен блокировками от одновременного доступа. Блокировки организованы достаточно эффективно, чтобы не создавать большой конкуренции. Любая страница, с которой работает СУБД, попадает в кэш. Часто используемые страницы остаются в кэше надолго; редко используемые — вытесняются и заменяются другими страницами. Буфер, содержащий измененную страницу, называется «грязным». Процесс Background Writer постепенно записывает их на диск в фоновом режиме — это позволяет снизить нагрузку на диски и увеличить производительность. Если Background Writer не успевает записать вытесняемый серверным процессом грязный буфер, то процесс записывает его сам. С точки зрения производительности этого лучше не допускать.

### Журнал упреждающей записи (WAL)
В журал упреждающей записи (Write Ahead Log, WAL) записывается информация, достаточная для повторного выполнения всех действия с базой данных. Записи этого журнала обязаны попасть на диск раньше, чем изменения в соответствующей странице. Тогда при восстановлении можно прочитать страницу с диска, посмотреть в ней номер последней записи WAL, и применить к странице все записи WAL, которые еще не были применены. Записью журнала занимается процесс WAL Writer. Можно сохранять записи журнала непосредственно при фиксации изменений. В таком случае гарантируется, что зафиксированные данные не пропадут при сбое. Второй вариант — сохранять записи асинхронно, что более эффективно. В этом случае некоторые зафиксированные данные могут пропасть, но согласованность все равно гарантируется. Журнал состоит из нескольких файлов (обычно по 16 МБ), которые циклически перезаписываются. Старые файлы могут сохраняться и архивироваться процессом WAL Archiver. Поскольку страница может долго не попадать на диск, возникает необходимость хранить неопределенно много журнальных записей. Чтобы избежать этого, периодически происходит так называемая контрольная точка, при которой все грязные буферы принудительно сбрасываются на диск. Этим занимается процесс Checkpointer.

### MVCC
Идея многоверсионности (Muliversion Concurrency Control, MVCC) состоит в том, чтобы разделить два уровня представления данных. На нижнем уровне имеем дело со страницами и физическим хранением данных в них. На этом уровне при изменении строки таблицы хранятся несколько версий этой строки, как старые, так и текущая актуальная. При удалении строки она не удаляется физически из страницы, а помечается номером удалившей его транзакции. Новая строка помечается номером создавшей его транзакции. Обновление реализуется как удаление старой строки и вставка новой. Таким образом, в каждой версии строки хранится информация о начале и конце ее действия. На верхнем уровне имеем так называемые снимки данных. С помощью информации о начальном и конечном номере транзакции они отбирают версии строк, дающие согласованную картину на определенный момент времени. Транзакции работаю только со снимками данных. Они не имеют представления о физическом хранении и видят только те строки, которые предоставлены снимком. За счет этого достигается изоляция — каждая транзакция видит свою картину данных и не мешает другим, одновременно с ней работающим транзакциям. Преимущество многоверсионности перед реализациями, основанными только на блокировках, состоит в существенно большей эффективности, так как гарантируется, что блокируется только одновременное изменение одних и тех же строк. Но читатели никогда не блокируют писателей, а писатели — читателей. Старые версии строк, которые не видны ни одной из активных транзакций, должны быть физически удалены, чтобы освободить занимаемое ими место. Этим занимается процесс Autovacuum Launcher, запускающий для выполнения работы процессы Autovacuum Worker. Также очистку можно запустить вручную командой VACUUM.

### Изоляция
---
**NOTE**

Больше информации про изоляцию в PostgreSQL можно найти в разделе [transactions](https://github.com/yum-install-brains/postgresql-spot/blob/master/transactions/PostgreSQL_transactions.md).

---


### Логическая структура БД
![db_cluster.png](db_cluster.png)
**Кластер** – группа баз данных, управляемых сервером PostgreSQL, находящаяся на одном хосте.

**База данных** – коллекция объектов. Объект – структура данных, используемая для хранения или получения доступа к данным. В PostgreSQL объектами являются таблицы, индексы, последовательности, представления и т.д.  

У всех объектов есть OID (object identifier), представляющий собой 4-байтовый int. Чтобы сопоставить объект и его OID можно обратиться к системному каталогу:  
```sql
sampledb=# SELECT datname, oid FROM pg_database WHERE datname = 'sampledb';
 datname  |  oid  
----------+-------
 sampledb | 16384
(1 row)

sampledb=# SELECT relname, oid FROM pg_class WHERE relname = 'sampletbl';
  relname  |  oid  
-----------+-------
 sampletbl | 18740
(1 row)
```

### Физическая структура
![db_structure.png](db_structure.png)
На физическом уровне кластер БД представляет собой основной каталог (`$PGDATA`) и ряд подкаталогов и файлов. База данных – это подкаталог основного каталога и каждая таблица и индекс это как минимум один файл в этом подкаталоге. У каждого файла есть уникальный идентификатор – `relfilenode`. Таблицы и индексы как объекты БД идентифицируются с помощью `OID`, в то время как файлы таблиц и индексов идентифицируются с помощью `relfilenode`. Обычно, `OID` и `relfilenode` совпадают, но операции типа `TRUNCATE`, `REINDEX`, `CLUSTER` приводят к изменению `relfilenode`. Если размер файла таблицы или индекса превышает 1GB, создается дополнительный файл, называющийся `relfilenode.1`, затем `relfilenode.2` и так далее.

Для определения `relfilenode` таблиц и индексов можно использовать функцию
```sql
SELECT pg_relation_filepath('sampletbl');
 pg_relation_filepath
----------------------
 base/16384/18812
```

Файлы таблиц имеют дополнительные файлы, ассоциированные с ними. Они называются `relfilenode_fsm` (free space map) и `relfilenode_vm` (visibility map). Файлы таблиц имеют дополнительные файлы free space map, но не имеют visibility map.
```shell
$ cd $PGDATA
$ ls -la base/16384/18751*
-rw------- 1 postgres postgres  8192 Apr 21 10:21 base/16384/18751
-rw------- 1 postgres postgres 24576 Apr 21 10:18 base/16384/18751_fsm
-rw------- 1 postgres postgres  8192 Apr 21 10:18 base/16384/18751_vm
```

---
**NOTE**

Больше информации про физическое хранение данных в PostgreSQL можно найти в разделе [disk storage](https://github.com/yum-install-brains/postgresql-spot/blob/master/disk%20storage/postgresql_cheetsheets.md).

---

#### Tablespace
![db_tablespace.png](db_tablespace.png)
Tablespace – дополнительные данные, хранящиеся вне основного каталога. В основном каталоге хранятся только символьные ссылки на эти данные.

При создании `tablespace` по указанному пути автоматически создается каталог `PG _ 'Major version' _ 'Catalogue version number'`.

Например, при создании новой таблицы, принадлежащей БД, созданной в основном каталоге, сперва будет создан новый каталог под `tablespace`, в котором будут создан подкаталог с OID текущей БД и затем в нем создан файл таблицы.  
```sql
sampledb=# CREATE TABLE newtbl (.....) TABLESPACE new_tblspc;

sampledb=# SELECT pg_relation_filepath('newtbl');
             pg_relation_filepath             
----------------------------------------------
 pg_tblspc/16386/PG_9.4_201409291/16384/18894
```

#### Содержание PGDATA:

| Элемент | Описание     |
| :------------- | :------------- |
|  PG_VERSION	| Файл, содержащий номер основной версии Postgres Pro |
|  base	| Подкаталог, содержащий подкаталоги для каждой базы данных |
|  current_logfiles	| Файл, в котором отмечается, в какие файлы журналов производит запись сборщик сообщений |
|  global	| Подкаталог, содержащий общие таблицы кластера, такие как pg_database |
|  pg_commit_ts	| Подкаталог, содержащий данные о времени фиксации транзакций |
|  pg_dynshmem	| Подкаталог, содержащий файлы, используемые подсистемой динамически разделяемой памяти |
|  pg_logical	| Подкаталог, содержащий данные о состоянии для логического декодирования |
|  pg_multixact	| Подкаталог, содержащий данные о состоянии мультитранзакций (используемые для разделяемой блокировки строк) |
|  pg_notify	| Подкаталог, содержащий данные состояния прослушивания и нотификации (LISTEN/NOTIFY) |
|  pg_replslot	| Подкаталог, содержащий данные слота репликации |
|  pg_serial	| Подкаталог, содержащий информацию о выполненных сериализуемых транзакциях. |
|  pg_snapshots	| Подкаталог, содержащий экспортированные снимки (snapshots) |
|  pg_stat	| Подкаталог, содержащий постоянные файлы для подсистемы статистики. |
|  pg_stat_tmp	| Подкаталог, содержащий временные файлы для подсистемы статистики |
|  pg_subtrans	| Подкаталог, содержащий данные о состоянии подтранзакций |
|  pg_tblspc	| Подкаталог, содержащий символические ссылки на табличные пространства |
|  pg_twophase	| Подкаталог, содержащий файлы состояний для подготовленных транзакций |
|  pg_wal	| Подкаталог, содержащий файлы WAL (журнал предзаписи) |
|  pg_xact	| Подкаталог, содержащий данные о состоянии транзакции |
|  postgresql.auto.conf	| Файл, используемый для хранения параметров конфигурации, которые устанавливаются при помощи ALTER SYSTEM |
|  postmaster.opts	| Файл, содержащий параметры командной строки, с которыми сервер был запущен в последний раз |
|  postmaster.pid	| Файл блокировки, содержащий идентификатор (ID) текущего управляющего процесса (PID), путь к каталогу данных кластера, временную метку запуска управляющего процесса, номер порта, путь к каталогу Unix-сокета (пустой для Windows), первый корректный адрес прослушивания (listen_address) (IP-адрес или *, либо пустое значение в случае отсутствия прослушивания по TCP), и ID сегмента разделяемой памяти (этот файл отсутствует после остановки сервера). |

### Источники
- Документация и обучающие статьи postgrespro.ru
- Материалы с сайта interdb.jp
