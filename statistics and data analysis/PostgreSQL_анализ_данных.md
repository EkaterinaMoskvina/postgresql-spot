## Статистика и анализ данных
#### Фактическая информация по [B-tree индексу](https://postgrespro.ru/docs/postgrespro/10/pgstattuple)
Информация собирается чтением всех страниц индекса.  
```sql  
SELECT * FROM pgstatindex('schema_name.table_name');  
-[ RECORD 1 ]------+----------  
version            | 2  
tree_level         | 3  
index_size         | 361717760  
root_block_no      | 16607  
internal_pages     | 417  
leaf_pages         | 43737  
empty_pages        | 0  
deleted_pages      | 0  
avg_leaf_density   | 33.67  
leaf_fragmentation | 49.24  
```

| Столбец     | Описание     |
| :------------- | :------------- |
| version               | Версия B-tree       |
| tree_level            | Уровень корневой страницы в дереве       |
| index_size            | Общий объём индекса в байтах       |
| root_block_no         | Расположение страницы корня (0, если её нет)       |
| internal_pages        | Количество «внутренних» страниц (верхнего уровня)       |
| leaf_pages            | Количество страниц на уровне листьев       |
| empty_pages           | Количество пустых страниц       |
| deleted_pages         | Количество удалённых страниц       |
| avg_leaf_density      | Средняя плотность страниц на уровне листьев (в %. Чем выше тем лучше. В идеале должно соответствовать значению fillfactor)       |
| leaf_fragmentation    | Фрагментация на уровне листьев (тоже в %, вероятно. Чем выше, тем хуже. Если большие значения, значит много пустого места и стоит сделать reindex.)      |

Листья - это 8KB странички, которые хранят данные из таблицы в логически отсортированном порядке и организованы в виде двусвязных списков. Если при добавлении новой строки в таблицу, в текущем листе не хватает места для новой записи, происходит добавление, т.е. появляется еще одна страничка листа, связанная с предыдущей как двусвязный список. При удалении и обновлении записей в таблице, происходит их удаление и в индексе, в связи с чем страницы индекса начинают содержать пустое место и занимать на диске и в памяти больше места, чем нужно (фрагментация).

#### Фактическая информация по [таблице](https://postgrespro.ru/docs/postgrespro/10/pgstattuple)
Информация собирается чтением всех страниц таблицы.  
```sql
SELECT * FROM pgstattuple('schema_name.table_name');
-[ RECORD 1 ]------+----------
table_len          | 999006208
tuple_count        | 2261310
tuple_len          | 486961920
tuple_percent      | 48.74
dead_tuple_count   | 18
dead_tuple_len     | 3760
dead_tuple_percent | 0
free_space         | 490253164
free_percent       | 49.07
```

| Столбец | Значение     |
| :------------- | :------------- |
| table_len           | Физическая длина отношения в байтах       |
| tuple_count         | Количество «живых» кортежей       |
| tuple_len           | Общая длина «живых» кортежей в байтах     |
| tuple_percent       | Процент «живых» кортежей       |
| dead_tuple_count    | Количество «мёртвых» кортежей       |
| dead_tuple_len      | Общая длина «мёртвых» кортежей в байтах       |
| dead_tuple_percent  | Процент «мёртвых» кортежей       |
| free_space          | Общий объём свободного пространства в байтах       |
| free_percent        | Процент свободного пространства       |

#### Статистика по [распределению данных в полях таблицы](https://postgrespro.ru/docs/postgrespro/10/view-pg-stats)
Так как расчитывается на основе статистики (analyze), может содержать не совсем корректные сведения. Для увеличения достоверности данных можно увеличить значение собираемой статистики по данному полю (параметр statistics).
```sql
SELECT * FROM pg_stats
WHERE tablename = 'table_name'
  AND schemaname = 'schema_name'
  AND attname='attr_name';
-[ RECORD 1 ]----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
schemaname             | schema_name
tablename              | table_name
attname                | attr_name
inherited              | f
null_frac              | 0
avg_width              | 8
n_distinct             | 1698
most_common_vals       | {"2014-09-11 00:00:00","2011-09-14 00:00:00","2014-01-06 00:00:00","2014-01-05 00:00:00","2014-01-11 00:00:00","2017-11-16 00:00:00","2014-01-08 00:00:00","2017-04-05 00:00:00","2
most_common_freqs      | {0.1232,0.0550367,0.0406333,0.0273067,0.0258933,0.0235833,0.02057,0.0177333,0.01366,0.0134767,0.0133767,0.01328,0.00983667,0.00938667,0.00779,0.0075,0.00718333,0.00700667,0.00631,
histogram_bounds       | {"2011-09-16 00:00:00","2011-09-21 00:00:00","2011-09-23 00:00:00","2011-09-27 00:00:00","2011-09-29 00:00:00","2011-09-30 00:00:00","2011-09-30 00:00:00","2011-10-04 00:00:00","2
correlation            | 0.212783
most_common_elems      | NULL
most_common_elem_freqs | NULL
elem_count_histogram   | NULL
```

| Столбец | Значение     |
| :------------- | :------------- |
| inherited       | Если true, в данных этой строки учитываются значения в дочерних столбцах, а не только в указанной таблице       |
| null_frac       | Доля записей, в которых этот столбец содержит NULL       |
| avg_width       | Средний размер элементов в столбце, в байтах       |
| n_distinct       | Число, большее нуля, представляет примерное количество различных значений в столбце. Если это число меньше нуля, его модуль представляет количество различных значений, делённое на количество строк. (Отрицательная форма применяется, когда ANALYZE полагает, что число различных значений, скорее всего, будет расти по мере роста таблицы; положительная, когда в столбце, вероятно, будет фиксированное количество возможных значений.) Например, -1 указывает на столбец с уникальным содержимым, в котором количество различных значений совпадает с количеством строк.       |
| most_common_vals       | Список самых частых значений в столбце. (NULL, если не находятся значения, появляющиеся чаще других.)       |
| most_common_freqs       | Список частот самых частых значений, то есть число их вхождений, делённое на общее количество строк. (NULL, вместе с most_common_vals.)      |
| histogram_bounds       | Список значений, разделяющих значения столбца на примерно одинаковые популяции. Значения most_common_vals, если они присутствуют, не рассматриваются при вычислении этой гистограммы. (Этот столбец содержит NULL, если для типа данных столбца не определён оператор <, либо если в most_common_vals перечисляется вся популяция.)       |
| correlation       | Статистическая корреляция между физическим порядком строк и логическим порядком значений столбца. Допустимые значения лежат в диапазоне -1 .. +1. Когда значение около -1 или +1, сканирование индекса по столбцу будет считаться дешевле, чем когда это значение около нуля, как результат уменьшения случайного доступа к диску. (Этот столбец содержит NULL, если для типа данных столбца не определён оператор <.)       |
| most_common_elems       | Важно только для нескалярных типов (типа массивов). Список элементов, отличных от NULL, наиболее часто присутствующих в значениях столбца. (NULL для скалярных типов.)       |
| most_common_elem_freqs       | Важно только для нескалярных типов (типа массивов). Список частот самых частых элементов, то есть доля строк, содержащих минимум один экземпляр данного значения. За частотами по элементам следуют два или три дополнительных значения: минимум и максимум предшествующих частот по элементам и дополнительно частота элементов NULL. (Принимает значение NULL вместе с most_common_elems.)       |
| elem_count_histogram       | Важно только для нескалярных типов (типа массивов). Гистограмма количеств различных и отличных от NULL элементов в значениях этого столбца, за которой следует среднее количество элементов, отличных от NULL. (Принимает значение NULL для скалярных типов.)      |

Статистика собирается раз в PGSTAT_STAT_INTERVAL (500 ms) миллисекунд. Также статистика обновляется каждым бэкендом в момент, когда он готовится перейти в idle состояние. Статистика в рамках одной транзакции постоянна (до коммита видна будет одна и та же статистика). Транзакция может видеть некоторые изменения, вызванные действиями в этой транзакции. Подробнее https://www.postgresql.org/docs/10/static/monitoring-stats.html.

#### [pg_statistic](https://postgrespro.ru/docs/postgrespro/9.6/catalog-pg-statistic)
В каталоге pg_statistic хранится статистическая информация о содержимом базы данных. Записи в нём создаются командой ANALYZE, а затем используются планировщиком запросов. Заметьте, что все эти данные по природе своей неточные, даже если предполагается, что они актуальны.

**В pg_statistic также хранится статистическая информация о значениях выражений функциональных индексов**. Она описывается так же, как если бы это были столбцы данных; в частности, starelid ссылается на индекс. Однако для столбцов, задействуемых в индексе без выражений, дополнительная запись не добавляется, так как она повторяла бы запись для нижележащего столбца таблицы.

Пример увеличения статистики по функциональному индексу:
```sql
CREATE TABLE public.test_table(key int, val text);
CREATE INDEX public.idx_test_table_val_lower ON test_table (lower(val));

\d public.idx_test_table_val_lower
Index "public.idx_test_table_val_lower"
┌────────┬──────┬────────────┐
│ Column │ Type │ Definition │
├────────┼──────┼────────────┤
│ lower  │ text │ lower(val) │
└────────┴──────┴────────────┘
btree, for table "public.test_table"

ALTER TABLE public.idx_test_table_val_lower ALTER lower SET STATISTICS 10000;
ANALYZE public.test_table;

SELECT stanullfrac, stawidth, stadistinct
FROM pg_statistic
WHERE starelid = 'public.idx_test_table_val_lower'::regclass;
```

Над каталогом `pg_statistics` существует представление, называемое `pg_stats`.

Максимальным числом записей в полях-массивах можно управлять на уровне столбцов, используя команду `ALTER TABLE SET STATISTICS`, или глобально, задав параметр времени выполнения `default_statistics_target`.

Планировщик запросов должен оценить число строк, возвращаемых запросов, чтобы сделать правильный выбор в отношении плана запроса. В частности, статистика включает общее число записей в каждой таблице и индексе, а также число дисковых блоков, которые они занимают.

#### ANALYZE
Количество самплов, выбираемое PostgreSQL во время выполнения команды ANALYZE расчитывается по формуле
```
(300 * statistics_target)
```

Сами самплы берутся каждый раз рандомно.

Статистика снимается по полям таблиц и по функциональным индексам. **Статистика не снимается по частичным функциональным индексам (c WHERE условием)!**

Подробнее можно почитать тут – https://github.com/postgres/postgres/blob/master/src/backend/statistics/README.
